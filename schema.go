package annot8

import (
	"fmt"
	"go/ast"
	"log/slog"
	"strings"
	"sync"
)

// SchemaGenerator handles dynamic schema generation from Go types
// If a TypeIndex is provided, it will be used for fast lookup.
type SchemaGenerator struct {
	schemas        map[string]*Schema
	typeIndex      *TypeIndex
	mutex          sync.Mutex
	currentPackage string // tracks the package of the struct being processed
}

// NewSchemaGenerator creates a new schema generator. Optionally accepts a TypeIndex.
func NewSchemaGenerator(opts ...*TypeIndex) *SchemaGenerator {
	slog.Debug("[annot8] NewSchemaGenerator: initializing", "opts_len", len(opts))
	var idx *TypeIndex
	if len(opts) > 0 && opts[0] != nil {
		idx = opts[0]
	} else {
		// Use global typeIndex if no specific index provided
		ensureTypeIndex() // Ensure typeIndex is initialized
		idx = typeIndex
	}

	return &SchemaGenerator{
		schemas:   make(map[string]*Schema),
		typeIndex: idx,
	}
}

// GenerateSchema creates a JSON schema for the given type name.
// All types are stored using qualified names (e.g., "order.CreateReq", "sqlc.User").
func (sg *SchemaGenerator) GenerateSchema(typeName string) *Schema {
	slog.Debug("[annot8] GenerateSchema: called", "typeName", typeName)

	// 1) Fast-path simple/empty types
	if typeName == "" || typeName == "<autogenerated>" {
		slog.Debug("[annot8] GenerateSchema: empty typeName, returning object schema")
		return &Schema{Type: "object"}
	}

	// 2) For basic types, return directly without caching
	if isBasicType(typeName) {
		return sg.generateBasicTypeSchema(typeName)
	}

	// 3) Normalize the type name to use qualified names
	qualifiedName := sg.getQualifiedTypeName(typeName)
	slog.Debug("[annot8] GenerateSchema: type name conversion", "typeName", typeName, "qualifiedName", qualifiedName)

	// 4) Check external known types
	if sg.typeIndex != nil {
		if schema, ok := sg.typeIndex.externalKnownTypes[qualifiedName]; ok {
			slog.Debug("[annot8] GenerateSchema: using externalKnownTypes", "qualifiedName", qualifiedName)
			// Store in sg.schemas so it can be post-processed (renamed) if needed,
			// but only if it's not a reference itself.
			sg.mutex.Lock()
			if _, exists := sg.schemas[qualifiedName]; !exists && schema.Ref == "" {
				sg.schemas[qualifiedName] = schema
			}
			sg.mutex.Unlock()
			return schema
		}
	}

	// 5) Check if schema already exists (avoid duplicate work)
	sg.mutex.Lock()
	if existingSchema, exists := sg.schemas[qualifiedName]; exists {
		sg.mutex.Unlock()
		if existingSchema == nil {
			// Currently being processed, return reference
			return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName)}
		}
		slog.Debug("[annot8] GenerateSchema: schema already exists", "qualifiedName", qualifiedName)
		return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName)}
	}

	// 6) Reserve placeholder to prevent infinite recursion
	sg.schemas[qualifiedName] = nil
	sg.mutex.Unlock()

	// 7) Check if it's an enum type
	if enumSchema := sg.handleEnumType(qualifiedName); enumSchema != nil {
		slog.Debug("[annot8] GenerateSchema: detected enum type", "qualifiedName", qualifiedName)
		sg.mutex.Lock()
		sg.schemas[qualifiedName] = enumSchema
		sg.mutex.Unlock()
		return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName)}
	}

	// 8) Generate the actual schema
	var built *Schema
	if sg.typeIndex != nil {
		// Try qualified lookup first
		if ts := sg.typeIndex.LookupQualifiedType(qualifiedName); ts != nil {
			slog.Debug("[annot8] GenerateSchema: found type in TypeIndex", "qualifiedName", qualifiedName)

			// Save old package context and set new one
			oldPkg := sg.currentPackage
			if idx := strings.LastIndex(qualifiedName, "."); idx != -1 {
				sg.currentPackage = qualifiedName[:idx]
			}

			// Use convertFieldType to handle structs, maps, slices, etc.
			// This ensures that type aliases like 'type WeeklyHours map[string]int' are correctly handled.
			if _, ok := ts.Type.(*ast.StructType); ok {
				built = sg.convertStructToSchema(ts.Type.(*ast.StructType))
			} else {
				built = sg.convertFieldType(ts.Type)
			}

			// Restore old package context
			sg.currentPackage = oldPkg
		}
	}

	// 9) Fallback for unknown types
	if built == nil {
		slog.Debug(
			"[annot8] GenerateSchema: TypeIndex lookup failed, using basic mapping",
			"qualifiedName",
			qualifiedName,
		)
		basicType := mapGoTypeToOpenAPI(qualifiedName)
		built = &Schema{
			Type:        basicType,
			Description: "externally defined or unknown",
		}
	}

	// 10) Store the built schema
	sg.mutex.Lock()
	slog.Debug("[annot8] GenerateSchema: storing schema", "qualifiedName", qualifiedName, "originalTypeName", typeName)
	sg.schemas[qualifiedName] = built
	if sg.typeIndex != nil && sg.typeIndex.externalKnownTypes != nil {
		sg.typeIndex.externalKnownTypes[qualifiedName] = &Schema{
			Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName),
		}
	}
	sg.mutex.Unlock()

	// 11) Always return a reference
	return &Schema{Ref: fmt.Sprintf("#/components/schemas/%s", qualifiedName)}
}

// getQualifiedTypeName returns the qualified type name for schema keys.
// It uses the TypeIndex if available, otherwise falls back to the original name.
func (sg *SchemaGenerator) getQualifiedTypeName(typeName string) string {
	// If already qualified, return as-is
	if strings.Contains(typeName, ".") {
		slog.Debug("[annot8] getQualifiedTypeName: already qualified", "typeName", typeName)
		return typeName
	}

	// If we're inside a package context, try to qualify with that package first
	if sg.currentPackage != "" && sg.typeIndex != nil {
		if _, exists := sg.typeIndex.types[sg.currentPackage][typeName]; exists {
			qualified := sg.currentPackage + "." + typeName
			slog.Debug(
				"[annot8] getQualifiedTypeName: qualified using currentPackage",
				"typeName",
				typeName,
				"package",
				sg.currentPackage,
				"qualified",
				qualified,
			)
			return qualified
		}
	}

	if sg.typeIndex != nil {
		qualified := sg.typeIndex.GetQualifiedTypeName(typeName)
		slog.Debug("[annot8] getQualifiedTypeName: converted", "typeName", typeName, "qualifiedName", qualified)
		return qualified
	}
	slog.Debug("[annot8] getQualifiedTypeName: no typeIndex, using original", "typeName", typeName)
	return typeName
}

// GetSchemas returns all generated schemas.
func (sg *SchemaGenerator) GetSchemas() map[string]Schema {
	slog.Debug("[annot8] GetSchemas: returning all generated schemas", "count", len(sg.schemas))
	result := make(map[string]Schema, len(sg.schemas))
	for name, schema := range sg.schemas {
		result[name] = *schema
	}
	return result
}
